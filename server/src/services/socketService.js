const Game = require('../models/Game');
const User = require('../models/User');
const { calculateCardPoints } = require('../utils/gameUtils');

// Stocker les connexions actives
const activeConnections = new Map();

// Configurer les gestionnaires d'Ã©vÃ©nements Socket.IO
exports.setupSocket = (io) => {
  io.on('connection', (socket) => {
    console.log(`Nouvelle connexion: ${socket.id}`);

    // Ã‰vÃ©nement lorsqu'un joueur rejoint une partie
    socket.on('join_game', async ({ gameCode, userId }) => {
      try {
        // VÃ©rifier que l'utilisateur existe
        const user = await User.findById(userId);
        if (!user) {
          return socket.emit('error', { message: 'Utilisateur non trouvÃ©' });
        }

        // Trouver la partie
        const game = await Game.findOne({ code: gameCode });
        if (!game) {
          return socket.emit('error', { message: 'Partie non trouvÃ©e' });
        }

        // VÃ©rifier si le joueur est dÃ©jÃ  dans la partie
        let player = game.players.find(p => p.user.toString() === userId);
        
        if (!player) {
          // VÃ©rifier s'il reste de la place
          if (game.players.length >= game.maxPlayers) {
            return socket.emit('error', { message: 'La partie est complÃ¨te' });
          }
          
          // Ajouter le joueur Ã  la partie
          player = {
            user: userId,
            socketId: socket.id,
            position: game.players.length + 1,
            cards: [],
            score: 0,
            hasThrown: false,
            hasBombom: false,
            isEliminated: false
          };
          
          game.players.push(player);
          await game.save();
        } else {
          // Mettre Ã  jour le socketId du joueur existant
          player.socketId = socket.id;
          await game.save();
        }

        // Enregistrer la connexion
        activeConnections.set(socket.id, { userId, gameCode });
        
        // Rejoindre la salle de la partie
        socket.join(gameCode);
        
        // Informer tous les joueurs de la mise Ã  jour
        io.to(gameCode).emit('game_updated', await getGameState(game));
        
      } catch (error) {
        console.error('Erreur lors de la connexion Ã  la partie:', error);
        socket.emit('error', { message: 'Erreur lors de la connexion Ã  la partie' });
      }
    });

    // Ã‰vÃ©nement lorsqu'un joueur quitte la partie
    socket.on('leave_game', async () => {
      try {
        const connection = activeConnections.get(socket.id);
        if (!connection) return;

        const { userId, gameCode } = connection;
        const game = await Game.findOne({ code: gameCode });
        
        if (game) {
          // Retirer le joueur de la partie
          game.players = game.players.filter(p => p.user.toString() !== userId);
          
          // Si c'Ã©tait l'hÃ´te, dÃ©signer un nouvel hÃ´te
          if (game.host.toString() === userId && game.players.length > 0) {
            game.host = game.players[0].user;
          }
          
          // Si plus de joueurs, supprimer la partie
          if (game.players.length === 0) {
            await Game.deleteOne({ _id: game._id });
          } else {
            await game.save();
            // Informer les autres joueurs
            io.to(gameCode).emit('game_updated', await getGameState(game));
          }
        }
        
        // Quitter la salle
        socket.leave(gameCode);
        activeConnections.delete(socket.id);
        
      } catch (error) {
        console.error('Erreur lors de la dÃ©connexion de la partie:', error);
      }
    });

    // Gestion de la dÃ©connexion
    socket.on('disconnect', async () => {
      console.log(`DÃ©connexion: ${socket.id}`);
      const connection = activeConnections.get(socket.id);
      if (!connection) return;

      const { userId, gameCode } = connection;
      
      try {
        const game = await Game.findOne({ code: gameCode });
        if (!game) return;
        
        // Marquer le joueur comme dÃ©connectÃ©
        const player = game.players.find(p => p.user.toString() === userId);
        if (player) {
          player.socketId = null;
          await game.save();
          
          // Informer les autres joueurs
          io.to(gameCode).emit('player_disconnected', { userId });
        }
      } catch (error) {
        console.error('Erreur lors de la gestion de la dÃ©connexion:', error);
      }
      
      activeConnections.delete(socket.id);
    });

    // Ã‰vÃ©nements de jeu
    socket.on('play_card', async ({ gameCode, userId, cardIndex, targetIndex }) => {
      try {
        const game = await Game.findOne({ code: gameCode });
        if (!game) return;
        
        const player = game.players.find(p => p.user.toString() === userId);
        if (!player || player.isEliminated) return;
        
        // VÃ©rifier que c'est le tour du joueur
        if (game.players[game.currentPlayerIndex].user.toString() !== userId) {
          return socket.emit('error', { message: 'Ce n\'est pas votre tour' });
        }
        
        // Logique de jeu (simplifiÃ©e pour l'exemple)
        if (cardIndex >= 0 && cardIndex < player.cards.length) {
          const playedCard = player.cards[cardIndex];
          
          // Ajouter la carte au cimetiÃ¨re
          game.discardPile.push({
            card: playedCard,
            playerId: userId,
            timestamp: new Date()
          });
          
          // Retirer la carte de la main du joueur
          player.cards.splice(cardIndex, 1);
          
          // VÃ©rifier si le joueur a gagnÃ© ou perdu
          checkPlayerStatus(game, player);
          
          // Passer au joueur suivant
          await game.nextPlayer();
          
          // Sauvegarder et diffuser l'Ã©tat mis Ã  jour
          await game.save();
          io.to(gameCode).emit('game_updated', await getGameState(game));
        }
      } catch (error) {
        console.error('Erreur lors du jeu de la carte:', error);
        socket.emit('error', { message: 'Erreur lors du jeu de la carte' });
      }
    });

    // Rejoindre une room de table
    socket.on('joinTableRoom', (tableId) => {
      console.log(`Socket ${socket.id} joining table room: ${tableId}`);
      socket.join(`table_${tableId}`);
      console.log(`Socket ${socket.id} joined room: table_${tableId}`);
    });

    // Quitter une room de table
    socket.on('leaveTableRoom', (tableId) => {
      console.log(`Socket ${socket.id} leaving table room: ${tableId}`);
      socket.leave(`table_${tableId}`);
    });

    // Toggle Ready status
    socket.on('player:toggle_ready', async ({ tableId, userId }) => {
      try {
        const Game = require('../models/Game');
        const game = await Game.findById(tableId);
        
        if (!game) {
          return socket.emit('error', { message: 'Table non trouvÃ©e' });
        }

        const player = game.players.find(p => p.user.toString() === userId);
        if (!player) {
          return socket.emit('error', { message: 'Joueur non trouvÃ©' });
        }

        // Toggle ready status
        player.isReady = !player.isReady;
        await game.save();

        console.log(`ðŸŽ® Player ${userId} ready status: ${player.isReady}`);

        // Ã‰mettre l'Ã©tat mis Ã  jour
        io.to(`table_${tableId}`).emit('player:ready_changed', {
          userId,
          isReady: player.isReady,
          allReady: game.players.every(p => p.isReady)
        });

        // Si tous les joueurs sont ready, dÃ©marrer la partie automatiquement
        if (game.players.length === game.maxPlayers && game.players.every(p => p.isReady)) {
          console.log(`ðŸš€ All players ready! Starting game...`);
          game.status = 'playing';
          await game.save();
          
          io.to(`table_${tableId}`).emit('game:auto_start', {
            message: 'Tous les joueurs sont prÃªts ! La partie commence...'
          });
        }
      } catch (error) {
        console.error('Erreur toggle ready:', error);
        socket.emit('error', { message: 'Erreur lors du changement de statut' });
      }
    });

    // Quitter la partie en cours
    socket.on('player:quit_game', async ({ tableId, userId }) => {
      try {
        const Game = require('../models/Game');
        const game = await Game.findById(tableId);
        
        if (!game) {
          return socket.emit('error', { message: 'Table non trouvÃ©e' });
        }

        const quittingPlayer = game.players.find(p => p.user.toString() === userId);
        if (!quittingPlayer) {
          return socket.emit('error', { message: 'Joueur non trouvÃ©' });
        }

        console.log(`ðŸšª Player ${userId} quit the game`);

        // Marquer le joueur comme Ã©liminÃ©
        quittingPlayer.isEliminated = true;
        
        // L'autre joueur gagne automatiquement
        const winner = game.players.find(p => p.user.toString() !== userId);
        
        game.status = 'finished';
        await game.save();

        // Notifier tous les joueurs
        io.to(`table_${tableId}`).emit('game:player_quit', {
          quitterId: userId,
          winnerId: winner.user.toString(),
          message: `${quittingPlayer.username} a quittÃ©. ${winner.username} gagne par forfait !`
        });
      } catch (error) {
        console.error('Erreur quit game:', error);
        socket.emit('error', { message: 'Erreur lors de la dÃ©connexion' });
      }
    });

    // Autres Ã©vÃ©nements de jeu Ã  implÃ©menter...
  });
};

// VÃ©rifier l'Ã©tat d'un joueur (Ã©limination, victoire, etc.)
function checkPlayerStatus(game, player) {
  const score = player.cards.reduce((sum, card) => sum + card.points, 0);
  player.score = score;
  
  if (score > 100) {
    player.isEliminated = true;
  } else if (score === 100) {
    player.score = 50; // RÃ©initialiser Ã  50 points
  }
}

// Obtenir l'Ã©tat actuel du jeu pour un client
async function getGameState(game) {
  const populatedGame = await Game.populate(game, [
    { path: 'players.user', select: 'firstName lastName elo' },
    { path: 'host', select: 'firstName lastName elo' }
  ]);

  return {
    code: populatedGame.code,
    status: populatedGame.status,
    currentPlayerIndex: populatedGame.currentPlayerIndex,
    maxPlayers: populatedGame.maxPlayers,
    cardsPerPlayer: populatedGame.cardsPerPlayer,
    host: populatedGame.host,
    players: populatedGame.players.map(p => ({
      _id: p.user._id,
      firstName: p.user.firstName,
      lastName: p.user.lastName,
      elo: p.user.elo,
      position: p.position,
      score: p.score,
      cardsCount: p.cards.length,
      isEliminated: p.isEliminated,
      hasBombom: p.hasBombom
    })),
    discardPile: populatedGame.discardPile,
    drawPileCount: populatedGame.drawPile.length,
    explorationEndTime: populatedGame.explorationEndTime,
    turnEndTime: populatedGame.turnEndTime
  };
}

// Export utilitaire pour rÃ©utilisation cÃ´tÃ© contrÃ´leurs (REST)
module.exports.getGameState = getGameState;
